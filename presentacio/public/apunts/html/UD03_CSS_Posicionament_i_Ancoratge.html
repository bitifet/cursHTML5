<!DOCTYPE HTML>
<html>
<head>
<title>UD03_CSS_Posicionament_i_Ancoratge</title>
<link rel="stylesheet" type="text/css" href="/stylesheets/apunts.css" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<h1 id="ud03---posicionament-i-ancoratge">UD03 - Posicionament i Ancoratge</h1>
<p><a href="./Planificacio.html">(⇧ Planificacio)</a></p>
<h1 id="índex">Índex</h1>
<!-- vim-markdown-toc GitLab -->
<ul>
<li><a href="#posicionament-i-ancoratge">Posicionament i ancoratge</a>
<ul>
<li><a href="#tipus-de-posicionament">Tipus de posicionament</a>
<ul>
<li><a href="#static">static</a></li>
<li><a href="#relative">relative</a></li>
<li><a href="#absolute">absolute</a></li>
<li><a href="#fixed">fixed</a></li>
<li><a href="#sticky">sticky</a></li>
</ul></li>
<li><a href="#ancoratge-dels-elements">Ancoratge dels elements</a></li>
<li><a href="#model-de-capes">Model de Capes</a>
<ul>
<li><a href="#la-propietat-z-index">La propietat <em>z-index</em></a></li>
<li><a href="#el-stacking-context">El <em>stacking context</em></a></li>
</ul></li>
<li><a href="#model-de-caixa-box-model">Model de Caixa (Box Model)</a>
<ul>
<li><a href="#voreres">Voreres</a></li>
<li><a href="#propietat-border-radius">Propietat <code>border-radius</code></a></li>
<li><a href="#propietat-box-sizing">Propietat <code>box-sizing</code></a>
<ul>
<li><a href="#establir-el-box-sizing-de-forma-global-wip">Establir el box-sizing de forma global (WIP)</a></li>
</ul></li>
</ul></li>
<li><a href="#marges">Marges</a>
<ul>
<li><a href="#marges-negatius">Marges negatius</a></li>
<li><a href="#marges-colapsats">Marges colapsats</a></li>
</ul></li>
<li><a href="#recursos">Recursos</a></li>
</ul></li>
<li><a href="#javascript-components-css">Javascript - Components CSS</a>
<ul>
<li><a href="#css-modular">CSS Modular</a></li>
<li><a href="#components-javascriptjquery-css">Components Javascript/jQuery + CSS</a></li>
<li><a href="#exercici-4">Exercici 4</a></li>
</ul></li>
</ul>
<!-- vim-markdown-toc -->
<ul>
<li>CSS - Posicionament i Ancoratge</li>
<li>Javascript - Components CSS</li>
</ul>
<h1 id="posicionament-i-ancoratge">Posicionament i ancoratge</h1>
<p><a href="/setslide/posicionament">Posicionament</a></p>
<h2 id="tipus-de-posicionament">Tipus de posicionament</h2>
<p>La propietat <code>position</code> estableix la forma en que es posicionen els elements dins el document i pot agafar els següents valors:</p>
<h3 id="static">static</h3>
<p><a href="/setslide/pos_static">Posicionament Estàtic</a></p>
<ul>
<li><p>És el valor per defecte.</p></li>
<li><p>L'element es posiciona d'acord al flux normal del document.</p></li>
<li><p>Les propietats <em>top</em>, <em>right</em>, <em>bottom</em>, <em>left</em> i <em>z-index</em> no ténen efecte amb aquest tipus de posicionament.</p></li>
<li><p>Es diu que els elements amb <em>posítion = static</em> <strong>no estan posicionats</strong>.</p></li>
</ul>
<h3 id="relative">relative</h3>
<p><a href="/setslide/pos_relative">Posicionament Relatiu</a></p>
<ul>
<li><p>Com amb <em>static</em>, l'element es posiciona d'acord al flux normal del document.</p></li>
<li><p>Les propietats <em>top</em>, <em>right</em>, <em>bottom</em> i <em>left</em> el desplacen de la seva posició natural <strong>però les posicions dels altres elements no es veuen afectats</strong>.</p></li>
<li><p>Els valors de <em>z-index</em> distints de &quot;auto&quot; crearàn un nou &quot;context d'amuntegament&quot; o <em>stacking context</em>.</p></li>
</ul>
<h3 id="absolute">absolute</h3>
<p><a href="/setslide/pos_absolute">Posicionament Absolut</a></p>
<ul>
<li><p>L'element s'elimina del flux normal del document (ja no es crea un espaï per a ell).</p></li>
<li><p>És posicionat, mitjançant les propietats <em>top</em>, <em>right</em>, <em>bottom</em> i <em>left</em>, en relació al seu ancestre posicionat més proper o, si no n'hi ha cap, relatiu al contenidor inicial.</p></li>
<li><p>Els valors de <em>z-index</em> distints de &quot;auto&quot; crearàn un nou &quot;context d'amuntegament&quot; o <em>stacking context</em>.</p></li>
</ul>
<h3 id="fixed">fixed</h3>
<p><a href="/setslide/pos_fixed">Posicionament Fix</a></p>
<ul>
<li><p>L'element s'elimina del flux normal del document (ja no es crea un espaï per a ell).</p></li>
<li><p>És posicionat, mitjançant les propietats <em>top</em>, <em>right</em>, <em>bottom</em> i <em>left</em>, en relació al contenidor inicial.</p></li>
<li><p>Sempre crea un nou <em>stacking context</em>.</p></li>
<li><p>En documents impresos (<span class="citation">@media</span> print) apareix a totes les pàgines i sempre a la mateixa posició.</p></li>
</ul>
<h3 id="sticky">sticky</h3>
<p><a href="/setslide/pos_sticky">Posicionament Sticky</a></p>
<ul>
<li><p>De recent introducció (pot no funcionar en alguns navegadors).</p></li>
<li><p>L'element es posiciona d'acord al flux normal del document. Però si el document (o un subcontenidor) es desplaça de manera que l'element anés a quedar ocult, es &quot;desenganxa&quot; quedant-se fitxat a un <em>offset</em> determinat.</p></li>
<li><p>No funciona en elements en que la propietat <em>overflow</em> valgui <em>hidden</em> o <em>auto</em>.</p></li>
</ul>
<h2 id="ancoratge-dels-elements">Ancoratge dels elements</h2>
<p><a href="/setslide/display">Display</a></p>
<p>La propietat &quot;display&quot; especifica el comportament de l'element en relació als elements que l'envolten i als que conté.</p>
<p>El seu valor per defecte depèn del tipus d'element: Per exemple, per a un <code>div</code> és &quot;block&quot; mentre que per un <code>span</code> és &quot;inline&quot;.</p>
<p>De fet aquests dos son els seus possibles valors més elementals:</p>
<p><a href="/setslide/display_values">Valors de Disyplay</a></p>
<ul>
<li><code>inline</code>: L'element s'integra &quot;en línia&quot; amb els altres elements. Les seves dimensions s'adapten al contingut (els atributs <em>width</em> i <em>height</em> no ténen cap efecte).</li>
<li><code>block</code>: Mostra l'element com un bloc que comença en una nova línia i agafa tota l'amplada disponible i l'alçada necessària per allotjar el contingut a no ser que les fixem amb les propietats <em>width</em> i <em>height</em>, respectivament..</li>
</ul>
<p>Addicionalment tenim un tercer valor que és una combinació dels dos anteriors:</p>
<p><a href="/setslide/more_display_values">Més valors de Display</a></p>
<ul>
<li><code>inline-block</code>: Que flueix igual que els elements <em>inline</em> però permet fixar les seves dimensions (comportant-se, de portes endins, com un element de bloc).</li>
</ul>
<p>N'hi ha bastantes més, com <em>flex</em> i <em>grid</em> de les que parlarem més endavant. Però aquestes son les més essencials i, juntament amb <em>flex</em> i <em>grid</em>, les úniques que manejarem en la majoria dels casos.</p>
<h2 id="model-de-capes">Model de Capes</h2>
<p><a href="/setslide/layer_model">Model de Capes</a></p>
<p>Quan activam el posicionament (<em>position</em> distint de <em>static</em>), els elements es poden moure (<em>relative</em>) del lloc que ténen assignat o fins i tot deixar d'ocupar cap espaï pel que fa al flux normal del contingut (<em>absolute</em>, <em>fixed</em>...).</p>
<p>Això fa que puguin sol·lapar-se amb altres.</p>
<p>Per decidir quin element es dibuixa a sobre de quin altre tenim una regla molt senzilla: <strong>El que apareix més avall al DOM es pinta davant</strong>. És a dir: van &quot;trepitjant-se&quot; a mida que es renderitzen.</p>
<h3 id="la-propietat-z-index">La propietat <em>z-index</em></h3>
<p><a href="/setslide/z-index">Z-Index</a></p>
<p>De vegades això no és suficient i necessitam poder definir quins elements cobriran quins...</p>
<p>Per això tenim la propietat <em>z-index</em>:</p>
<ul>
<li><p>El valor per defecte de la propietat <em>z-index</em> és &quot;auto&quot;, que significa que els elements seguiran la regla anterior.</p></li>
<li><p>Però <em>z-index</em> també pot agafar un valor numèric enter.</p></li>
<li><p>Els elements amb z-index positíu o zero es situaran per sobre dels que ténen <em>z-index</em> &quot;auto&quot; i més al front com més elevat sigui el seu valor.</p></li>
<li><p>Els elements amb z-index negatiu es situaran per davall fins i tot dels elements no posicionats i més avall com menor sigui el seu valor.</p></li>
</ul>
<h3 id="el-stacking-context">El <em>stacking context</em></h3>
<p><a href="/setslide/stacking_context">Stacking Context</a></p>
<p>Sempre que assignam un valor distint de &quot;auto&quot; a la propietat &quot;z-index&quot; (o el tipus de posicionament és un dels que ja hem indicat que el creen sempre), es crearà un nou <em>Stacking Context</em> en relació a l'element.</p>
<p>Això vol dir que tots els elements que contengui podràn intercalar-se entre ells segons les regles anteriors, però <strong>cap element exterior podrà intercalar-se entre dos d'ells</strong>.</p>
<p>Per aquest motiu no és recomanable abusar de la propietat <em>z-index</em>.</p>
<h2 id="model-de-caixa-box-model">Model de Caixa (Box Model)</h2>
<p><a href="/setslide/box_model">Model de Caixa</a></p>
<p>Tots els elements HTML es poden considerar &quot;caixes&quot;.</p>
<div class="img right">
<img src="../../images/figures/boxmodel.gif" />
</div>
<p>Cadascuna d'aquestes caixes consta (de dins cap a fora) de 4 &quot;sub-caixes&quot;: el propi contingut, el &quot;padding&quot; (farcit), el &quot;border&quot; (vorera) i el &quot;margin&quot; (marge).</p>
<p>Les propietats <em>padding</em>, <em>border</em> i <em>margin</em> ens permeten controlar les dimensions d'aquests.</p>
<p><a href="/setslide/box_model_properties">Propietats del Model de Caixa</a></p>
<p>Encara que el nom de les propietats sigui en singular, consideram que tenim 4 <em>paddings</em>, 4 <em>borders</em> i 4 <em>margins</em>. De fet, aquestes propietats anteriors son <em>shorthands</em> de <em>padding-top</em>, <em>padding-right</em>, <em>padding-bottom</em> i <em>padding-left</em>, i el mateix amb <em>margin-</em>, respectivament.</p>
<h3 id="voreres">Voreres</h3>
<p><a href="/setslide/box_model_borders">Voreres</a></p>
<p>La propietat <em>border</em>, en canvi, és el shorthand de:</p>
<ul>
<li><em>border-width</em></li>
<li><em>border-style</em> (requerit, per defecte &quot;none&quot;)</li>
<li><em>border-color</em></li>
</ul>
<p>I només permet especificar tots a l'hora (si volem valors distints segons el costat haurem de fer servir <em>border-top</em>, <em>border-right</em>, etcètera... o dirèctament <em>border-top-width</em>, <em>border-top-style</em>, <em>border-top-color</em>...</p>
<p><a href="/setslide/box_model_border-style">Estil de Voreres</a></p>
<p><em>border-style</em> pot agafar entre d'altres els següents valors:</p>
<ul>
<li><strong>&quot;none&quot; (per defecte):</strong> No hi ha voreres.</li>
<li><strong>&quot;solid&quot;:</strong> Estableix un &quot;border&quot; sòlid (el més comú).</li>
<li><strong>&quot;dotted&quot;:</strong> Puntejat.</li>
<li><strong>&quot;dashed:</strong> Discontinu.</li>
<li>...</li>
<li><strong>hidden:</strong> Invisible (però ocupa l'espaï que li correspòn). Útil per a transicions (per exemple <em>:hover</em>) sense que les coses s'ens moguin de lloc.</li>
</ul>
<h3 id="propietat-border-radius">Propietat <code>border-radius</code></h3>
<p><a href="/setslide/box_model_border-radius">Cantons Arrodonits</a></p>
<p>La propietat <em>border-radius</em> ens permet arrodonir els cantons de la caixa.</p>
<p>Com que &quot;border-radius-top&quot; seria ambigu, en aquest cas, <strong>només tenim la propietat &quot;border-radius&quot; exclusivament</strong>.</p>
<p>Així <em>border-radius</em> ens permet especificar tots els radis a l'hora, dos a dos, etc... Per saber en quin ordre els hem d'introduïr podem continuar fent servir la regla de seguir el sentit de les agulles del rellotge amb només tombar el nostre &quot;rellotge&quot; 45º cap a l'esquerra (o &quot;partir de les 10 i mitja en comptes de les 12).</p>
<h3 id="propietat-box-sizing">Propietat <code>box-sizing</code></h3>
<p><a href="/setslide/box_model_box-sizing">Box-Sizing</a></p>
<p><strong>La propietat <em>box-sizing</em> estableix què mesuren les propietats <code>height</code>, <code>width</code>, respectivament</strong> com també les seves derivades (<code>min-height</code>, <code>max-height</code>, ...).</p>
<p>Sense comptar <code>initial</code> (que en aquest cas equivaldria a <code>content-box</code> i <code>inherit</code>, la propietat <code>box-sizing</code> pot agafar dos valors:</p>
<ul>
<li><p>content-box.</p></li>
<li><p>border-box.</p></li>
</ul>
<p>Així, quan està establerta a <code>content-box</code> (per defecte), <code>height</code>, <code>width</code>, etc... defineixen el tamany del contingut. <strong>Per això, si afegim voreres, marges o, fins i tot <em>padding</em>, L'ELEMENT ENS OCUPARÀ MÉS ESPAÏ del que hem especificat</strong>.</p>
<p>En canvi, si l'establim a <code>border-box</code> aquesta mesura inclourà també el <em>padding</em> i les vores (<em>border</em>), fent molt més senzilla la tasca de sumar els espaïs que ens ocupa cada element a l'hora de maquetar.</p>
<blockquote>
<p><strong>⚠  Alerta:</strong> Així i tot, encara haurem de tenir en compte els marges, si en tenim.</p>
</blockquote>
<h4 id="establir-el-box-sizing-de-forma-global-wip">Establir el box-sizing de forma global (WIP)</h4>
<p><a href="/setslide/box_model_box-sizing_globally">Box-Sizing Global</a></p>
<p>Si ho preferim, podem establir el <code>box-sizing</code> a <code>border-box</code> de forma global amb una senzilla regla:</p>
<pre><code>*,
::before,
::after {
  box-sizing: border-box; 
}</code></pre>
<blockquote>
<p>💣 Però si estam treballant en un projecte preexistent, podria passar que tinguéssim codi css anterior que, al estar calculat segons el comportament per defecte, deixas de funcionar corrèctament.</p>
<p>El mateix ens pot passar si fem servir frameworks css externs que hagin estat dissenyats en base a <code>border-sizing: content-box</code>. Si be molts, com <em>Bootstrap</em> ja fan servir <code>border-box</code> i/o fixen explícitament aquesta propietat per al seu css.</p>
</blockquote>
<p><a href="/setslide/box_model_box-sizing_globally_refined">Més Box-Sizing Global</a></p>
<p>En qualsevol cas, el següent exemple ens mostra una forma més refinada de fer-ho:</p>
<pre><code>:root {
  box-sizing: border-box;
}

*,
::before,
::after {
  box-sizing: inherit;
}</code></pre>
<p>Establint <code>box-sizing</code> a <code>inherit</code> obrim la possibilitat de canviar aquesta propietat recursivament de forma selectiva a les parts que ens interessi del DOM (per exemple <code>.oldCss {box-sizing: content-box;}</code>) mentre que la regla que hem definit sobre el selector <code>:root</code> ens garanteix que la resta heredarà el valor <code>border-box</code>.</p>
<p><a href="/setslide/moreCSS">Més CSS</a></p>
<h2 id="marges">Marges</h2>
<h3 id="marges-negatius">Marges negatius</h3>
<p>Una cosa que no tot-hom sap és que establir marges negatius és vàlid a CSS.</p>
<p>Si establim un valor negatiu als marges passarà el que tots intuïtivament pensam: el contingut <strong>(més el padding)</strong> sobresurtirà del contenidor. De manera que si el padding és menor que el valor absolut del marge negatiu, el contingut ens pot sortir fora.</p>
<p>El que passi aleshores depèn de la propietat <em>overflow</em>: si és &quot;display&quot; és sol·laparà amb els elements de fora del contenidor i si és &quot;hidden&quot;, &quot;scroll&quot; o &quot;auto&quot; simplement quedarà ocult.</p>
<h3 id="marges-colapsats">Marges colapsats</h3>
<p>Els marges, com els <em>paddings</em> serveixen per deixar espaï en blanc, evitant així que el nostre disseny quedi sobrecarregat o fins i tot costi de llegir.</p>
<p>Però els marges concretament, serveixen per establir un mínim espaï de separació <strong>entre dos elements</strong>.</p>
<p>En canvi, a tots els elements els podem establir un marge. Així que entre dos elements donats <strong>tenim dos valors distints a considerar</strong>.</p>
<p>Com hem dit, els marges estableixen una separació <strong>mínima</strong> entre dos elements (no entre un element i la part exterior del marge de l'altre).</p>
<p>Per això, <strong>els marges (normalment) no es sumen</strong>, sino que s'agafa sempre el valor més gran dels elements a separar.</p>
<p>Quan passa això diem que <strong>els marges han col·lapsat</strong>.</p>
<p>Però no en tots els casos els marges col·lapsen...</p>
<p><strong>Casos en que els marges no colapsen:</strong></p>
<ul>
<li><p>Establint la propietat <code>overflow</code> a qualsevol valor distint de <code>visible</code> a un contenidor s'evita que els marges interiors colapsin amb els exteriors.</p></li>
<li><p>Si hi ha una vorera (border) entre dos marges (per exemple transparent, si la volem fer servir com a truc per evitar el colapsament).</p></li>
<li>Cap a fora d'un contenidor dels següents contenidors:
<ul>
<li>Flotant (&quot;floated&quot;)</li>
<li>Amb la propietat <code>display</code> a <code>inline-block</code>.</li>
<li>Amb posicionament absolut (<code>position: absolute</code>) o fix (<code>position: fixed</code>)</li>
</ul></li>
<li><p>A dins d'un contenidor flexbox (<code>display: flex</code>) o grid (<code>display: grid</code>).</p></li>
<li><p>Els elements amb <code>display: table-cell</code>, <code>table-row</code> i la majoria de la resta de tipus de display de taules a excepció de <code>table</code>, <code>table-inline</code> i <code>table-caption</code> no tenen marges, així que no poden colapsar.</p></li>
</ul>
<h2 id="recursos">Recursos</h2>
<ul>
<li>Model de Caixa: <a href="">https://www.w3schools.com/css/css_boxmodel.asp</a></li>
</ul>
<h1 id="javascript---components-css">Javascript - Components CSS</h1>
<h2 id="css-modular">CSS Modular</h2>
<p>Quan començam a escriure CSS és molt comú que anem escrivint les regles a mesura que les necessitam per a donar estil a un element concret.</p>
<p>De manara que acabam tenint un CSS infinit plè de regles super-específiques que, a sobre, acaben aplicant-se accidentalment a llocs pels que no havien estat pensades.</p>
<p>A més, la nostra pàgina acaba per no tenir consistència visual ja que els elements d'una secció i d'una altra han estat dissenyats per separat sense un criteri uniforme.</p>
<p>Pensar le nostre CSS de forma <em>modular</em> ens permet evitar aquest problema.</p>
<p>Per exemple, si necessitam posar un botó, podem assignar-li la classe &quot;button&quot; i estilitzar-lo de la següent manera:</p>
<pre><code>.button {
  padding: 0.5em 0.8em;
  border: 1px solid #265559;
  border-radius: 0.2em;
  background-color: transparent;
  font-size: 1rem;
}</code></pre>
<p>Fins aquí res de nou.</p>
<p>Però que passa quan necessitam un botó lleugerament distint? Per exemple un botó que denoti que quelcom ha anat bé.</p>
<p>Instintivament podriem crear-ne un de nou o copiar l'anterior, per exemple com a &quot;.successButton&quot; i fer les modificacions necessàries.</p>
<p>Això funcionaria i tindria certa coherència: Fins al dia que decidim canviar el tamany de &quot;.button&quot; que, si no ens recordam de fer-ho també a tots els seus &quot;clons&quot;, acabarem tenint múltiples tipus de botons que no ténen res a veure els uns amb els altres.</p>
<p>Així que, en comptes d'això, definirem la següent regla:</p>
<pre><code>.button--success {
  border-color: #cfe8c9;
  color: #fff;
  background-color: #2f5926;
}</code></pre>
<p>Aquí definim <strong>una variant</strong> del botó anterior. Per això abans dels dos guions (--) hem fet servir el mateix nom de la classe original. I després indicam la variació que aquesta regla implementa.</p>
<p>Així, per crear un &quot;Success Button&quot; fariem el següent:</p>
<pre><code>&lt;span class=&quot;button button--success&quot;&gt;Ok&lt;/span&gt;</code></pre>
<p>Fent servir la mateixa tècnica podem definir:</p>
<p><strong>Botons de perill:</strong></p>
<pre><code>.button--danger {
  border-color: #e8c9c9;
  color: #fff;
  background-color: #a92323;
}</code></pre>
<p><strong>Botons més petits:</strong></p>
<pre><code>.button--small {
  font-size: 0.8rem;
}</code></pre>
<p><strong>Botons més grans:</strong></p>
<pre><code>.button--large {
  font-size: 1.2rem;
}</code></pre>
<p>...i combinar-los a gust:</p>
<pre><code>&lt;span class=&quot;button button--danger button--large&quot;&gt;D&#39;acord!&lt;/span&gt;</code></pre>
<h2 id="components-javascriptjquery-css">Components Javascript/jQuery + CSS</h2>
<p>Ara imaginem un component una mica més complex.</p>
<p>Recordem l'Exercici 2 en que vam implementar un menú de tipus &quot;popup&quot;.</p>
<p>Algú ha intentat fer-lo servir des del telèfon mòbil?</p>
<p>Que passa quan passau el rat... Oh!! Espereu!!!! ...no tenim ratolí!!! Com obrim el menú???</p>
<p><strong>NO PODEM!!</strong></p>
<p>I tampoc no cal anar tan enfora. Fins i tot en un PC, no sempre que el ratolí passi per sobre del títol del menú serà perquè voliem obrir aquest: A lo millor només hi hem passat perquè estava a mig camí d'un altre element que, ara que s'ens ha obert el menú a lo millor fins i tot ens el tapa!!.</p>
<blockquote>
<p>📌 El selector <code>:hover</code> va molt bé per crear <em>tooltips</em> més elaborats que una simple propietat &quot;title&quot;. Pero per a obrir un menú rarament serà una bona idea des del punt de vista d'usabilitat.</p>
</blockquote>
<p>Normalment per obrir o tancar un menú, es fa servir l'event de &quot;click&quot;. Però per això necessitarem javascript.</p>
<hr />
<h2 id="exercici-4">Exercici 4</h2>
<p>Recuperau el menú de l'exercici anterior al que ja resoliem aquest problema canviant la Pseudo-Classe <em>:hover</em> per una Classe normal i afegiem i treiem aquesta cada cop que l'usuari clicava sobre el títol del menú.</p>
<ul>
<li><p>Acabau-lo si no el teniu acabat.</p></li>
<li>Què passava al contingut de davall del menú quan obriem aquest?
<ul>
<li>Ara, amb el que heu après avui sobre posicionament CSS teniu les eines per a corregir-ho.</li>
</ul></li>
<li><p>Revisau el codi. Podriem considerar-lo un <em>component CSS</em>?</p></li>
<li><p>Si la classe principal és prou específica, la part de <em>Javascript/jQuery</em> també la podrem considerar part del component.</p></li>
<li><strong>Opcional:</strong> Modificau el menú afegint un atribut &quot;action&quot; que especifiqui una acció. Seguidament modificau el controlador javascript per tal que quan seleccionem una opció, ens mostri un &quot;alert()&quot; amb el seu contingut i tanqui el menú.
<ul>
<li>Addicionalment podeu canviar aquest &quot;alert()&quot; per disparar un event sobre el document i implementar la seva captura.</li>
</ul></li>
</ul>
<hr />
<footer>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Llicència de Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
</footer>
<script src="/javascripts/jquery-3.3.1.min.js"></script>
<script src="/javascripts/remote_controller.js"></script>
</body>
</html>
