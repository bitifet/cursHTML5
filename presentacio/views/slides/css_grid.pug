



.slide(data-name="grid")
  div.medium

    h2.step.title CSS Grid

    p.step.
      El #[i Grid Layout] va apar√®ixer amb posterioritat a Flexbox.

    p.step.
      Per activar-lo fem servir:

    pre.code.frame.medium.step.
      .contenidor {
          display: grid; /* o inline-grid */
      }

    p.step.
      Podr√≠em dir que #[i Flexbox] ens permet repartir l'espai en una dimensi√≥
      (horitzontal o vertical) mentre que #[i Grid] ens permet fer-ho en dues
      dimensions a l'hora.

    p.step.
      Aix√≠mateix #[b Grid no reempla√ßa Flexbox], sin√≥ que son dos sistemes
      complementaris.

    ul
      li.step.
        #[i Flexbox] √©s m√©s senzill a l'hora de repartir l'espai de forma
        el√†stica entre m√∫ltiples elements.
      li.step.
        Per√≤ per treballar en dues dimensions necessitam anidar m√∫ltiples
        contenidors #[i Flex] un a dins l'altre.
        

.slide(data-name="grid_layout")
  div.bigfont

    h2 Maquetaci√≥ amb Grid

    p.step.
      Aix√≠, l'HTML de qualsevol #[i Grid] ser√† molt semblant al seg√ºent:

    pre.code.frame.step.
      &lt;div class="grid"&gt;
        &lt;div&gt;...&lt;/div&gt;
        &lt;div&gt;...&lt;/div&gt;
        &lt;div&gt;...&lt;/div&gt;
        ...
      &lt;/div&gt;


.slide(data-name="grid_concepts")
  div

    h2.step.title Conceptes b√†sics

    img.step.floatRight.medium(src="/images/figures/grid/grid-concepts.png")

    p.step.
      Per entendre Grid, necessitam assimilar uns pocs conceptes b√†sics:

    ul.medium

      li.step.
        #[b grid-item:] √âs cadascun dels elements que son fills directes del
        contenidor.
      li.step.
        #[b grid-line:] Son les l√≠nies horitzontals i verticals, tant interiors
        com exteriors, que conformen l'estructura de la graella.
      li.step.
        #[b grid-track:] √âs l'espai entre dues #[i grid-lines] adjacents.
      li.step.
        #[b grid-cell:] √âs l'espai que conformen dues #[i grid-lines]
        horitzontals i dues verticals respectivament adjacents.
      li.step.
        #[b grid-area:] Igual que una #[i grid-cell] per√≤ sense la condici√≥
        d'adjac√®ncia de les #[i grid-lines].


.slide(data-name="grid_properties")
  div

    h2 Propietats Principals

    p.step.
      Podriem dir que, conceptualment, el #[i CSS-Grid] √©s m√©s senzill que el
      #[i Flexbox].

    p.step.
      Per√≤ per altra banda √©s molt potent i vers√†til, en el sentit de que ens
      permet obtenir resultats molt diversos i, cadascun d'ells de diverses
      formes (i mitjan√ßant propietats) diferents. 

    p.step.
      Seguidament intentarem explicar un extracte de les t√®cniques i propietats
      m√©s usuals.

    p.step.
      Per a m√©s informaci√≥, a l'apartat de refer√®ncies dels apunts teniu un
      article molt complet del portal web #[i CSS Tricks] al respecte.

    p.step.moreinfo https://css-tricks.com/snippets/css/complete-guide-grid



.slide(data-name="grid_tplcolumns_tplrows")
  div

    h2 grid-template-columns i grid-template-rows (Contenidor)

    ul
      li.step
        span.
          #[b grid-template-columns:]
        ul
          li.step.
            Declara les columnes en les que els #[i items] s'aniran
            organitzant.
          li.step.
            Despr√©s del #[code.code display: grid;], √©s la primera propietat
            que necessitarem establir ja que
            #[b en cas contrari obtindr√≠em una graella d'una sola columna].
      li.step
        span.
          #[b grid-template-rows:]
        ul
          li.step.
            Declara les files en les que els #[i items] s'aniran
            organitzant.
          li.step.
            No √©s tan imprescindible ja que aquestes es crearan autom√†ticament
            a mesura que siguin necess√†ries.
          li.step.
            Si be, fer servir #[i grid-template-rows] ens permetr√† controlar la
            seva altura.  


.slide(data-name="grid_simple_example")
  div

    h3 CSS Grid - Exemple

    table
      tr
        td.step
          img.medium(src="/images/figures/grid/grid-numbers.png")

          pre.code.frame.white.step.medium.
            .container {
              display: grid;
              grid-template-columns:
                40px 50px auto 50px 40px;
              grid-template-rows: 25% 100px auto;
            }

        td.step
          h4 Markup:
          pre.code.frame.white.
            &lt;div class="grid"&gt;
                &lt;div&gt;Item 1&lt;/div&gt;
                &lt;div&gt;Item 2&lt;/div&gt;
                &lt;div&gt;Item 3&lt;/div&gt;
                &lt;div&gt;Item 4&lt;/div&gt;
                &lt;div&gt;Item 5&lt;/div&gt;
                &lt;div&gt;Item 6&lt;/div&gt;
                &lt;div&gt;Item 7&lt;/div&gt;
                &lt;div&gt;Item 8&lt;/div&gt;
                &lt;div&gt;Item 9&lt;/div&gt;
                &lt;div&gt;Item 10&lt;/div&gt;
                &lt;div&gt;Item 11&lt;/div&gt;
                &lt;div&gt;Item 12&lt;/div&gt;
                &lt;div&gt;...&lt;/div&gt;
            &lt;/div&gt;


.slide(data-name="grid_columns_rows")
  div

    h2 grid-column i grid-row (items)

    table
      tr
        td.step(rowspan=2)
          p.
            Ens permeten especificar, respectivament, la fila i/o columna a la
            que s'ha d'ubicar un element.
          p.step.
            #[b Exemple:]
          pre.code.frame.white.step.
            .very-first-item {
                grid-column: 1;
                grid-row: 1;
            }
          p.step.
            En realitat, el que especificam √©s
            #[b despr√©s de quin #[i grid-line] volem que s'ubiqui].

        td.step(colspan=2)
          p.
            De fet en realitat accepten 2 nombres de #[i grid-line], separats
            per una barra inclinada (/): #[b El d'inici i el de fi].

      tr
        td.step
          span.
            #[b Exemple:]
          pre.code.frame.white.small.
            .container {
              grid-template-columns: 50px 50px 50px 50px;
              grid-template-rows: auto;
            }
            .header {
              grid-column: 1 / 5;
              grid-row: 1 / 2; /* O simplement '1'  */
            }
            .main {
              grid-column: 1 / 3;
              grid-row: 2 / 3;
            }
            .sidebar {
              grid-column: 4 / 5;
              grid-row: 2 / 3;
            }
            .footer {
              grid-column: 1 / 5;
              grid-row: 3 / 4;
            }

        td.step
          p.small El que ens donaria el seg√ºent resultat:
          img.medium(src="/images/figures/grid/grid-template-areas.png")





##### Etiquetes


Una caracter√≠stica interessant de #[i grid-template-columns] i
#[i grid-template-rows] √©s que ens permeten inserir etiquetes entre cadascun dels
#[i grid-track] (columnes o files) que estem definint.

Les etiquetes es defineixen entre claud√†tors (`[]`). A m√©s, en podem definir
m√©s d'una a cada empla√ßament. Per exemple per delimitar el final d'una secci√≥ i
el principi d'una altra. Aix√≠, si algun dia volgu√©ssim canviar-les de lloc o
inserir una altra secci√≥ enmig, nom√©s caldria moure les etiquetes pertinents
sense necessitat de redefinir-les.


img.step.floatRight.small(src="/images/figures/grid/grid-names.png")

```
.container {
  display: grid;
  grid-template-columns:
    40px 50px auto 50px 40px;
  grid-template-rows:
    [row1-start] 25%
    [row1-end row2-start] 25%
    [row2-end]
  ;
}
```


__CLEARFIX__



#### grid-template-areas

img.step.floatRight.small(src="/images/figures/grid/grid-template-areas.png")

Les etiquetes ens simplifiquen enormement la feina de crear (i sobretot
mantenir) #[i layouts] complexes. Especialment quan no coneixem pr√®viament el
nombre d'elements (#[i grid-items]) que contindr√† la nostra graella o, sobretot,
si aquest pot variar.

Per√≤ #[b quan es tracta d'un #[i layout] est√†tic, la propietat #[i grid-template-areas] ens ofereix una forma molt millor]...

Per exemple, per implementar el mateix #[i layout] d'abans amb
#[i grid-template-areas], el CSS seria el seg√ºent:


```
.container {
  grid-template-columns: repeat(4, 50px);
  grid-template-rows: auto;
  grid-template-areas: 
    "header header header header"
    "main main . sidebar"
    "footer footer footer footer";
}
.header { grid-area: header; }
.main { grid-area: main; }
.sidebar { grid-area: sidebar; }
.footer { grid-area: footer; }
[...]
```


>
üìå #[b La funci√≥ #[i repeat()]:] Si ens hi fixam, al llistat anterior hem
canviat la declaraci√≥ `grid-template-columns: 50px 50px 50px 50px;` per
`grid-template-columns: repeat(4, 50px);`.
>
Aquesta funci√≥ ens permet abreviar a l'hora d'especificar patrons repetitius de
files o columnes.
>
En aquest cas hem repetit 4 vegades '50px'. Per√≤ podem repetir patrons molt m√©s
complexos. Exemple:
>
`grid-template-columns: repeat(6, 10px 20em 2fr 1fr);`
>


__CLEARFIX__


#### gap / grid-gap

img.step.floatRight.small(src="/images/figures/grid/grid-column-row-gap.png")

Fins ara hem vist com repartir l'espai de la graella i assignar-lo (o deixar
que es es reparteixin ells) als distints #[i grid-items].

Per√≤ els elements ens queden aferrats els uns als altres sense gens d'espai
enmig. El que no resulta gaire est√®tic...

Per solucionar aquest problema, tenim la propietat #[i gap] que ens permet
especificar un marge de separaci√≥ entre els elements.

__CLEARFIX__

>
üìå Originalment la propietat #[i gap] s'anomenava #[i grid-gap], pel que les
versions menys recents d'alguns navegadors nom√©s suporten aquesta darrera. Per
aquest motiu √©s recomanable fer servir #[i grid-gap] en comptes de #[i gap] o, en tot
cas les dues:
>
`gap: .5em;`
>
`grid-gap: var(gap);`
>

En realitat la propietat #[i gap] √©s el #[i shorthand] de les propietats #[i row-gap] i
#[i column-gap] que ens permeten especificar el "gap" entre files i entre
columnes, respectivament.

La propietat #[i gap] (o #[i grid-gap]) per√≤, ens permet a m√©s, especificar un √∫nic
"gap" per files i columnes.

Dit d'altra manera, les delcaracions `grid-gap 3px;` i `grid-gap 3px 3px;` son
equivalents.


__CLEARFIX__


### Graelles Din√†miques



img.step.floatRight.small(src="/images/figures/grid/grid-elastic-sample.png")

Suposem que tenim una s√®rie de fotografies i volem muntar una galeria
fotogr√†fica.

Tamb√© volem que algunes fotografies, escollides per nosaltres, surtin doble
tamany i que no ens quedi cap espai buid.

A m√©s, volem que les fotografies no siguin ni massa grosses ni massa petites i
que el conjunt s'ajusti a l'amplada disponible.


Com veurem despr√©s, podem especificar regles css que nom√©s s'apliquin segons si
el tamany de la pantalla compleix o no determinades condicions (com ara estar
dins un determinat rang).

El problema per√≤ √©s que, per fer-ho aix√≠, haur√≠em de dissenyar una distribuci√≥
distinta per a cada cas, com il¬∑lustren els exemples de la figura que mostren
m√∫ltiples configuracions segons un ample de pantalla determinat.


-----------------------------------------------------------------------------------------

Exercici 6
----------

1. Obteniu una s√®rie d'imatges i preparau un document html com el seg√ºent per a
   mostrar-les totes. Podeu anomenar els fitxers i els peus de foto com m√©s vos
   agradi:


```
<div class="album">
  <figure class="big">
    <img src="./view_01.jpeg" alt="Vista 1" />
    <figcaption>Vista 1</figcaption>
  </figure>
  <figure>
    <img src="./view_02.jpeg" alt="Vista 2" />
    <figcaption>Vista 2</figcaption>
  </figure>
  <figure class="big">
    <img src="./view_03.jpeg" alt="Vista 3" />
    <figcaption>Vista 3</figcaption>
  </figure>

  <figure> ... </figure>
  ...
</div>
```

2. Aplicau-li el seg√ºent full d'estil i observau que passa:

```

.album > figure {
  display: inline-block;
  max-width: 300px;
  margin: 0;
}

.album img {
  max-width: 100%;
  object-fit: cover;
}

.album figcaption {
  padding: 0.3em 0.8em;
  background-color: rgba(0, 0, 0, 0.5);
  color: #fff;
  text-align: right;
}

@supports (display: grid) {
  .album {
    display: grid;
    grid-template-columns:
        repeat(auto-fill, minmax(100px, 1fr));
    grid-auto-rows: 1fr;
    grid-gap: 1em;
    grid-auto-flow: dense;
  }

  .album > figure {
    display: flex;
    flex-direction: column;
    max-width: initial;
  }

  .album img {
    flex: 1;
  }

  .album .big {
    grid-row: span 2;
    grid-column: span 2;
  }
}
```


3. Provau a canviar el tamany de la finestra del navegador mentre estau
   visualitzant la p√†gina. Observau com les imatges canvien d'ordre si √©s
   necessari per tal de no deixar espais en blanc.

4. Identificau entre tots quines de les propietats que apar√®ixen al css
   anterior encara no coneixieu.  Investigau a la xarxa quina √©s la seva
   finalitat. Podeu fer-ho en grups i repartir-vos les propietats.

5. Experimentau que passa quan en treieu alguna d'elles.

-----------------------------------------------------------------------------------------




Disseny Responsiu
-----------------

Entenem per "dissenys responsius" (#[i Responsive Designs]) aquells que d'alguna
manera s'adapten a les caracter√≠stiques del dispositiu on son visualitzats
sense perdre gens o gaireb√© gens de funcionalitat.

Per a aconseguir aix√≤ podem fer servir dues estrat√®gies:

  * El #[i disseny adaptatiu].

  * Els #[i Media Queries].


### Disseny Adaptatiu (Elasticitat)

Per disseny adaptatiu entenem aquell que s'adapta al tamany del #[i viewport] de
forma progressiva. √âs a dir: si engrandim o escur√ßam el tamany de la finestra,
el contingut s'escala de forma gradual (i "apropiada").

Aqu√≠ juguen un paper molt important les unitats relatives. Especialment les
noves relatives a l'amplada i/o altura del #[i viewport]: #[code.code vw], #[code.code vh], #[code.code vmin] i
#[code.code vmax] que ens permeten dividir de forma exacta l'espai disponible amb unes
proporcions constants.

Abans de disposar d'aquestes unitats aix√≤ es feia t√≠picament fent servir
percentatges (%) per√≤, a no ser mitjan√ßant Javascript, resultava pr√†cticament
impossible evitar que ens apareguessin barres de despla√ßament indesitjades.


#### Tamany de lletra el√†stic.

Pel que fa al tamany de lletra, resulta poc pr√†ctic definir-lo en proporci√≥
directa al tamany del viewport ja que per a tamanys petits pot resultar
illegible mentre que amb pantalles molt grans podr√≠em estar desaprofitant
l'espai.

Per aix√≤ el m√©s convenient √©s establir un tamany de lletra m√≠nim amb unitats
absolutes (px, mm, etc...) #[b m√©s un increment relatiu l tamany de la pantalla].

#[b Exemple:]

```
:root {
  font-size: 14px;
  font-size: calc(2px + 2vw);
  font-size: calc(2px + 2vmin);
}
```

Aqu√≠ fem el seg√ºent:

  * Definim un tamany de lletra base de 14px per a aquells navegadors que no
    suportin unitats relatives al #[i viewport] (i pot ser tampoc la funci√≥ calc()).

  * Per a aquells navegadors que ho suportin, establim un tamany de lletra
    proporcional a l'amplada #[i viewport] al que afegim un #[i offset] de 2px.

  * Per a aquells navegadors que ho suportin (#[code.code vmin] i #[code.code vmax] estan
    lleugerament menys suportats que #[code.code vw] i #[code.code vh]), establim un tamany de lletra
    proporcional a la menor de les dimensions del #[i viewport] i li afegim el
    mateix #[i offset].

Com que hem aquest tamany de lletra a l'element arrel (:root), ja no ens caldr√†
m√©s repetir aquests c√†lculs donat que sempre que vulguem establir un tamany de
lletra diferent, ho podrem fer relatiu a aquest (*rem*) o al que estigu√©s
pr√®viament establert per her√®ncia (*em*).


>
üìå El fragment de CSS anterior, tret de la primera declaraci√≥
(`font-size: 14px;`) que no la vaig considerar necess√†ria √©s el tamany de
lletra base de les diapositives que heu estat veient tot el curs.
>
Per aquest motiu l'#[i offset] √©s tan petit: Ens interessava que la informaci√≥ que
es mostr√†s en pantalla fos sempre la mateixa #[b independentment de la resoluci√≥ d'aquesta].
>
Pel cas d'una p√†gina o aplicaci√≥ web normal, normalment far√≠em servir un
#[i offset] major i un increment m√©s moderat.
>



### Media Queries

Quan l'elasticitat no √©s suficient, els #[i media queries] ens permeten establir
regles CSS espac√≠fiques per als casos en que la pantalla √©s molt gran o molt
petita.

L'avantatge d'aquest procediment √©s que podem realitzar qualsevol canvi que
considerem oport√∫ al CSS. Fins i tot reestructurar completament el layout.

>
üìå Un exemple t√≠pic √©s convertir una barra de navegaci√≥ lateral en el
t√≠pic men√∫ "burguer" (‚ò∞) que habitualment veiem a les aplicacions m√≤bils.
>

L'inconvenient per√≤ √©s que els canvis no son progressius, sin√≥ que el canvi es
produeix de forma abrupta quan les dimensions del viewport comencen a o deixen
de complir una determinada condici√≥.


#[b Exemple de #[i Media Query]:]

```
@media (max-width: 600px) and (orientation: portrait) {
  .facet_sidebar {
    display: none;
  }
}
```

A les refer√®ncies teniu un enlla√ß a la documentaci√≥ de la MDN sobre #[i Media Queries] on trobareu ben detallades totes les condicions que podeu fer servir.


### Mobile-First Approach

Es coneix com a #[i Mobile-First Approach] a una #[b molt recomanable] forma
d'abordar els dissenys consistents en, tal com el seu nom indica, dissenyar
#[b primer] per al m√≤bil.

La idea b√†sica √©s que si fem un disseny que funcioni b√© a un dispositiu m√≤bil
(petit, sense ratol√≠...) ens ser√† molt m√©s senzill adaptar aquest a dispositius
m√©s grans (les adaptacions seran normalment per a aprofitar millor el
dispositiu: no perqu√® perqu√® res no hi funcioni), que no a l'inrev√©s.







//- vim: set ft=jade:
