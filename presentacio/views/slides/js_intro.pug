

.slide.bigfont(data-name="javascript")
  div
    h3.step.title Javascript

    ul
      li.step Assíncron
      li.step Orientat a Events
      li.step (Callbacks)
      li.step Event Loop

.slide.bigfont(data-name="ecmascript")
  div
    h3 Javascript
    h4.step (ECMASCRIPT / ES6+)

    table
      tr
        td.step ☞ ES6/ES2015
        td.step ☞ ES2016
        td.step ☞ ES2017
        td.step ☞ ES2018
        td.step ☞ ES2019 ...
      tr
        td.step Use
        td.step.code(colspan=4)
          code.code "use strict";

.slide.bigfont(data-name="js_vars")
  div
    h3 Variables

    ul
      li.step #[code.code var] Runtime Scope
      li.step #[code.code let] Block Scope (ES6+)
      li.step #[code.code const] Block Scope, not de-referenceable (ES6+)

.slide.bigfont(data-name="js_let")
  div
    h3 let / const (Block Scope)

    pre.step.
      const arr = [1, 2, 3, 4];
      for (let i=0; i&lt;arr.length; i++) {
          arr[i] += 2;
      };
      console.log (arr); // [3, 4, 5, 6]
      console.log (i); // Error!!
                       // Això amb en Franco no passava...


.slide.bigfont(data-name="js_closures")
  div
    h3 Clausures

    ul

      li.step Delimiten l'àmbit de visibilitat d'una variable.

      li.step Es creen automàticament #[b en invocar una funció].

      li.step.
        Les variables declarades dins una clausura només son visibles dins
        d'aquesta (#[i Runtime Scope]).

      li.step. 
        En canvi,
        #[els objectes que aquestes referencien, també poden ser referenciats des de l'exterior]
        si la funció retorna una referència a ells (#[i exposició]).


.slide.bigfont(data-name="js_closures_ex")
  div
    h3 Clausures (Exemple)

    pre.step.
      function sumador(n) { // Això no crea cap clausura.
          let x = n; // (en realitat hauriem pogut fer servir 'n')
          let fn = function suma(m) {
              x += m;
              return x;
          };
          return fn;
      };

      let s1 = sumador(0); // Això sí crea una clausura.
      let s2 = sumador(100); // I això una altra...

      console.log (s1(3)); // 3
      console.log (s1(5)); // 8
      console.log (s2(5)); // 105


.slide.bigfont(data-name="js_closures_iife")
  div
    h3 Clausures - IIFE

    p.step #[b IIFE:] Immediately Invoked Function Expression.

    pre.step.
      // Petit controlador secundari:
      (function(model) {
         ... implementació ...
      })(model.submodel.foo.bar);


    p.step La seva forma més senzilla és #[code.code (function(){...})()]

    table.step
      tr
        td.
          Amb l'aparició de #[code let] i #[code const] ja no son tan necessàries.#[br]
          Però continuen sent molt útils per aïllar petits submòduls específics.



.slide.bigfont(data-name="js_this")
  div
    h3 this

    pre.code.step.
      function foo() {
        const me = this;
        function bar() {
          return me === this; // false
        };
        const baz = ()=&gt;me===this; // true
      };

.slide.bigfont(data-name="js_this_not_that")

  div.medium
    h3 this this, not that this
    div.center
      div
        div.step
          code.code.
            const me = this;
        div.step
          h4 Spoiler
          pre.code.scratch.
            $(this).show();
            $(this).whatever();
            ...
          pre.code.
            const $this = $(this);
            $this.show();
            $this.whatever();
            ...
    table.step
      td.
        Recordau que amb la majoria de navegadors, fins i tot actuals, #[code const]
        #[br]no funcionarà: Cal #[i transpilar] el codi o fer servir #[code var].



.slide(data-name="es6+")
  div
    h3 Noves Funcionalitats ES6+

    div.center.bigfont
      ul
        li.step Let and Const.
        li.step Template literals.
        li.step Arrow Functions.
        li.step Destructuring.
        li.step #[code.code class]
        li.step etcètera...
      
    table.step
      tr
        th ⚠ Alerta!
        td.
          L'elecció del keyword #[code.code class] per a aquesta finalitat és
          controvertida perquè pot portar a confondre amb l'herència de classes
          d'altres llenguatges mentre que en Javascript #[b sempre] el que
          s'hereda és el prototip.


.slide(data-name="es6_backward_compatibility")
  div
    h3 Compatibilitat Cap Enrere
    h4 (Backward Compatibility)

    div.center.bigfont
      ul
        li.step Polyfills / Shims
          ul
            li.step (Detecció de Funcionalitats)
            li.step Modernizr

        li.step Transpiladors (Transpilers)
          ul
            li.step Babel
      

//- vim: set ft=jade:
